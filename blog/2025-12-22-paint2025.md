---
title: 2025 æ–°å¹´ç»˜æ¿â€”â€”è§„åˆ™è¯´æ˜ã€ API æ–‡æ¡£åŠæ ·ä¾‹
layout: blog
date: 2025-12-22
author: ZAMBAR
tags:
  - GeekPie
  - Paint
  - Post
---

# 2025 æ–°å¹´ç»˜æ¿

- Link: https://paint2025.geekpie.club
- æ´»åŠ¨æ—¶é—´ï¼šå³æ—¥èµ·è‡³ 2025/12/31 23:59:59

> [!note]
>
> æœ¬æ–‡æœ€è¿‘å·²äº 2025/12/24 02:55 (UTC+8) æœ‰æ›´æ–°ï¼Œä¹‹å‰çš„æ¶ˆæ¯å¯èƒ½è¿‡æ—¶ã€‚
>
> - 2025/12/24: é¢„ç¥å¤§å®¶åœ£è¯èŠ‚å¿«ä¹ï¼æˆ‘ä»¬ç´§æ€¥ä¿®å¤äº†æ ·ä¾‹ä¸­åœ¨æŸäº›æ ¡å›­ç½‘ç¯å¢ƒä¸‹æ— æ³•è®¿é—®æœåŠ¡å™¨çš„é—®é¢˜ ~~ï¼ˆå›¾ä¿¡ä½ å¹²å¾—å¥½å•Šï¼‰~~ï¼Œå¹¶æ›´æ–°äº†ç›¸å…³é…ç½®è¦æ±‚ã€‚

æ´»åŠ¨å…·ä½“è¯¦æƒ…è§ Event é¡µé¢

## è§„åˆ™è¡¥å……è¯´æ˜

- ç¬¬ä¸€å¤©ä¸ºäº†å¿«é€Ÿå æœ‰é¢†åœ°ï¼Œæˆ‘ä»¬ç»™å‡ºäº† 128 ä½“åŠ›æ§½å’Œ 1.5 ç§’çš„ä½“åŠ›æ¢å¤æ—¶é—´ï¼Œä¹‹åä¸ºäº†ä¿è¯ä½œå“ä¸ä¼šè¢«è¦†ç›–ï¼Œæˆ‘ä»¬ä¼šéšç€æ—¶é—´æ¨ç§»å¢åŠ å†·å´é—´éš”å’Œå‡å°‘ä½“åŠ›æ§½ã€‚
- æˆ‘ä»¬å…è®¸å¹¶æ”¯æŒç»„é˜Ÿï¼ˆåˆç†æ”¶é›†ä»–äºº Tokenï¼‰å’Œä½¿ç”¨ BOT ç»˜å›¾ï¼Œè¿™æœ‰åŠ©äºä½ å¿«é€Ÿçš„æ›´æ–°ç‰ˆå›¾ã€‚
- è¯·ä¸è¦æ¶æ„è¦†ç›–ä»–äººå›¾æ¡ˆã€‚
- è¯·ä¸è¦æ”»å‡»æœåŠ¡å™¨ï¼Œå…¬å¼€ä»–äººä¿¡æ¯ã€‚
- è¯·ä¸è¦ç»˜åˆ¶ä»»ä½•ä¸é€‚å½“çš„å†…å®¹ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºæ¶‰æ”¿ã€è‰²æƒ…ã€æš´åŠ›ã€ä»‡æ¨è¨€è®ºç­‰ã€‚

## API æ–‡æ¡£

### éç»˜ç”» API

#### POST `/api/auth/exchange` - ä»¤ç‰Œäº¤æ¢

> âš ï¸ï¼šæˆ‘ä»¬æ¨èæ‰‹åŠ¨è·å– Tokenï¼Œæ­¤å¤„ä»…ä¸ºåˆ—å‡ºã€‚

- **åŠŸèƒ½**: ä¸ Casdoor è¿›è¡Œ OAuth2 OIDC é›†æˆï¼Œäº¤æ¢ç”¨æˆ·ä»¤ç‰Œè·å–ä¼šè¯
- **è¯·æ±‚ä½“**: `{ token: string }`
- **è¿”å›**: åŒ…å« `sessionToken` å’Œç”¨æˆ·ä¿¡æ¯
- **è®¤è¯**: ä½¿ç”¨ Casdoor OIDC userinfo ç«¯ç‚¹éªŒè¯ä»¤ç‰Œ
- **å­˜å‚¨**: åœ¨ MongoDB ä¸­åˆ›å»º/æ›´æ–°ç”¨æˆ·ä¼šè¯ï¼Œåˆ†é…ç»˜åˆ¶ç‚¹æ•°é¢åº¦

#### GET `/api/place` - è·å–ç”»æ¿æ•°æ®

> âš ï¸ï¼šå¯èƒ½å­˜åœ¨å»¶è¿Ÿä¸”ç”±äº JSON æ ¼å¼å¼€é”€è¾ƒå¤§ï¼Œä»…ä¾›åˆå§‹åŒ–ï¼Œä¸æ¨èé¢‘ç¹ä½¿ç”¨ã€‚

- **åŠŸèƒ½**: è·å–å½“å‰ç”»æ¿ä¸Šæ‰€æœ‰å·²ç»˜åˆ¶çš„ç‚¹åŠé…ç½®ä¿¡æ¯
- **è¿”å›**:

  ```json
  {
    "status": true,
    "data": {
      "points": [],          // æ‰€æœ‰ç‚¹çš„æ•°æ® [{x, y, w, h, c, user}, ...]
      "colors": [],          // 32ç§é¢„ç½®é¢œè‰²
      "delay": 5             // ç»˜åˆ¶å»¶è¿Ÿæ—¶é—´ï¼ˆç§’ï¼‰
    }
  }
  ```

- **è®¤è¯**: æ— éœ€è®¤è¯

#### GET `/api/status` - ç»Ÿè®¡ä¿¡æ¯

- **åŠŸèƒ½**: è·å–åº”ç”¨çš„ç»Ÿè®¡æ•°æ®
- **è¿”å›**:

  ```json
  {
    "status": true,
    "data": {
      "totalActions": 12345,     // æ€»ç»˜åˆ¶æ“ä½œæ•°
      "totalUsers": 789,         // æ€»ç”¨æˆ·æ•°
      "timestamp": "2025-12-23..."
    }
  }
  ```

- **è®¤è¯**: æ— éœ€è®¤è¯

---

### ç»˜ç”» API

æœ¬æ¬¡ç»˜ç”»ç›¸å…³ API æ²¡æœ‰ä½¿ç”¨ HTTP Endpointï¼Œå› æ­¤æ‰€æœ‰çš„è¯·æ±‚éƒ½ä¸ä¼šäº§ç”Ÿæ–°çš„ HTTP è¯·æ±‚ï¼Œå¦‚éœ€æŠ“åŒ…è¯·ä»å¼€å§‹çš„ Websocket ä¼šè¯ä¸­æå–ä¿¡æ¯ã€‚

#### è¿æ¥ä¿¡æ¯

- åè®®: Socket.io v4 (å¹¶éåŸç”Ÿ WebSocket)
- ç«¯ç‚¹ (Endpoint): `https://paint2025.geekpie.club`
- å‘½åç©ºé—´ (Namespace): `/` (é»˜è®¤)
- è®¤è¯æ–¹å¼: åœ¨å»ºç«‹è¿æ¥æ¡æ‰‹ï¼ˆHandshakeï¼‰æ—¶ï¼Œéœ€è¦åœ¨ auth å¯¹è±¡ä¸­æºå¸¦ Tokenã€‚
  - Token è·å–æ–¹å¼ï¼šç™»å½•ç½‘é¡µç‰ˆåï¼Œåœ¨ Token è¾“å…¥æ¡†å¤åˆ¶æˆ–è€…åˆ·æ–°ã€‚

#### è¿æ¥æµç¨‹

è¦é€šè¿‡ API è¿›è¡Œç»˜ç”»ï¼Œä½ éœ€è¦ä½¿ç”¨ Websocket å»ºç«‹ä¸€ä¸ªä¼šè¯ï¼Œå¹¶ä¸”é€šè¿‡è¿™ä¸ªç»˜ç”»ä¸æ–­å‘é€å’Œç›‘å¬æ¶ˆæ¯ã€‚æˆ‘ä»¬å·²ç»é€šè¿‡ Socket.IO ç®€åŒ–äº†å¯¹åº”æµç¨‹ï¼Œå¤§è‡´æµç¨‹ä¸»è¦å¦‚ä¸‹ï¼š

1. **æ¡æ‰‹è®¤è¯**: ä½ éœ€è¦é€šè¿‡æºå¸¦ Token å‘é€è¯·æ±‚ï¼Œå®ç°å»ºè¿ã€‚
2. **ä¸­é—´ä»¶éªŒè¯**: æœåŠ¡å™¨éªŒè¯ä»¤ç‰Œæœ‰æ•ˆæ€§ï¼Œè§¦å‘ `authenticated` æ—¶é—´é€šçŸ¥è®¤è¯ç»“æœå’Œåˆå§‹ç‚¹æ•°ã€‚
3. **æˆ¿é—´åŠ å…¥**: æœåŠ¡å™¨æ ¹æ®ä»¤ç‰Œè‡ªåŠ¨å°†æ‚¨åŠ å…¥ Token å¯¹åº”æˆ¿é—´ï¼Œæˆ¿é—´å†…å¹¿æ’­ `sync` äº‹ä»¶ç”¨æ¥åŒæ­¥å‰©ä½™ç‚¹æ•°å’Œæœ€åè®¡ç®—æ—¶é—´ã€‚
4. **å¼€å§‹ç»˜ç”»**ï¼šå®¢æˆ·ç«¯å‘é€ `draw` äº‹ä»¶è¿›è¡Œç»˜ç”»ï¼Œä½ å¯ä»¥é€šè¿‡ Socket.IO çš„ Callback(ACK) æ¥è·å–è¿”å›ä¿¡æ¯ã€‚
5. **å¹¿æ’­æ›´æ–°**ï¼šç»˜ç”»æˆåŠŸåæœåŠ¡å™¨ç»Ÿä¸€å¹¿æ’­ `draw` äº‹ä»¶è¿›è¡Œå¢é‡æ›´æ–°ã€‚

#### äº‹ä»¶åˆ—è¡¨

| äº‹ä»¶å | æ–¹å‘ | è¯´æ˜ |
|--------|------|------|
| **authenticated** | æœåŠ¡å™¨â†’å®¢æˆ·ç«¯ | è¿æ¥å»ºç«‹æ—¶è¿”å›è®¤è¯ç»“æœå’Œåˆå§‹ç‚¹æ•° |
| **draw** | å®¢æˆ·ç«¯â†”æœåŠ¡å™¨ | å®¢æˆ·ç«¯è¯·æ±‚ç»˜åˆ¶æ“ä½œï¼ŒæœåŠ¡å™¨å¹¿æ’­ç»˜åˆ¶è¿›è¡ŒåŒæ­¥ï¼ˆå«é€Ÿç‡é™åˆ¶ã€ç‚¹æ•°æ¶ˆè€—ï¼‰ |
| **sync** | æœåŠ¡å™¨â†’å®¢æˆ·ç«¯ | è¿”å›ç»˜åˆ¶åå‰©ä½™ç‚¹æ•°å’Œæœ€åæ›´æ–°æ—¶é—´ |
| **onlineClientsUpdated** | æœåŠ¡å™¨â†’å®¢æˆ·ç«¯ | å¹¿æ’­åœ¨çº¿ç”¨æˆ·æ•°é‡å˜åŒ– |
| **disconnect** | ç³»ç»Ÿäº‹ä»¶ | ç”¨æˆ·æ–­å¼€è¿æ¥æ—¶è§¦å‘ |

#### æ•°æ®æ ¼å¼

##### `PointData`

æè¿°ä¸€ä¸ªåƒç´ ç‚¹

| å­—æ®µ | ç±»å‹ | è¯´æ˜ | ç¤ºä¾‹ |
| --- | --- | --- | --- |
| `x` | Integer | X åæ ‡ (`0` ~ `CANVAS_WIDTH-1`) | `100` |
| `y` | Integer | Y åæ ‡ (`0` ~ `CANVAS_HEIGHT-1`) | `200` |
| `c` | String | é¢œè‰² (Hex æ ¼å¼å­—ç¬¦ä¸²) | `"#FF0000"` |
| `w` | Number | å®½åº¦ (âš ï¸é™åˆ¶ä¸º 1ï¼Œå³å°†åˆ é™¤) | `1` |
| `h` | Number | é«˜åº¦ (âš ï¸é™åˆ¶ä¸º 1ï¼Œå³å°†åˆ é™¤) | `1` |
| `user` | String | **(ä»…æ¥æ”¶)** ç»˜åˆ¶è¯¥ç‚¹çš„ç”¨æˆ·å | `"user_123"` |

#### å®¢æˆ·ç«¯æ¨é€äº‹ä»¶

##### `draw`

ç”¨äºè¯·æ±‚åœ¨ç”»å¸ƒä¸Šç»˜åˆ¶ä¸€ä¸ªç‚¹ã€‚

- **é¢‘ç‡é™åˆ¶**: å—æœåŠ¡ç«¯ `DRAW_MAX_POINTS` å’Œ `DRAW_DELAY_MS` æ§åˆ¶ï¼ˆç±»ä¼¼äºä½“åŠ›æ§½æœºåˆ¶ï¼‰ã€‚
- **Payload ç»“æ„**:

    ```json
    {
        "data": { // å‚è€ƒ `PointData`
            "x": 100,
            "y": 200,
            "c": "#000000",
            "w": 1, // å¿…é¡»ä¸º 1
            "h": 1  // å¿…é¡»ä¸º 1
        },
        "token": "xxx" // å·²åºŸå¼ƒï¼Œæ— éœ€æºå¸¦
    }

    ```

- è¿”å›æ ·ä¾‹(å¤±è´¥)

    ```json
    {
        "code": -4,
        "message": "Insufficient points",
        "pointsLeft": 0 // å…¶ä»–æƒ…å†µä¸‹ä¸º undefined
    }
    ```

- è¿”å›æ ·ä¾‹(æˆåŠŸ)

    ```json
    {
        "code": 0,
        "message": "Draw successful",
        "pointsLeft": 10
    }
    ```

- é”™è¯¯ä»£ç å‚è€ƒ

    ```ts
    export enum AppErrorCode {
        Success = 0,                // æˆåŠŸ
        InvalidToken = -1,          // Token æ— æ•ˆ
        UnknownError = -2,          // æœªçŸ¥é”™è¯¯
        InvalidRequest = -3,        // è¯·æ±‚è½½è·ä¸æ­£ç¡®æˆ– Zod éªŒè¯å¤±è´¥
        InsufficientPoints = -4,    // ä½“åŠ›ä¸è¶³
        InvalidPosition = -5,       // ä½ç½®æ— æ•ˆ
    }
    ```

Example (Python):

```python
def on_draw_response(result):
    print(f"Draw response received: {result}")
    
    code = result.get('code')
    points_left = result.get('pointsLeft')
    last_update = result.get('lastUpdate')
    message = result.get('message', "Unknown Error")

payload = {
    "data": {
        "x": x,
        "y": y,
        "c": color,
        "w": 1,
        "h": 1
    }
}

self.sio.emit("draw", payload, callback=on_draw_response)
```

#### æœåŠ¡ç«¯æ¨é€äº‹ä»¶

å®¢æˆ·ç«¯éœ€è¦ç›‘å¬è¿™äº›äº‹ä»¶æ¥æ›´æ–°æœ¬åœ°çŠ¶æ€ã€‚

##### `authenticated`

è¿æ¥æˆåŠŸå¹¶éªŒè¯ Token åç«‹å³å‘é€ã€‚

- **æ•°æ®**:

    ```json
    {
        "success": true,
        "pointsLeft": 10,
        "lastUpdate": 1766427449915, // ms æ—¶é—´æˆ³
    }
    ```

##### `draw`

**å¹¿æ’­äº‹ä»¶**ã€‚å½“**å…¶ä»–ç”¨æˆ·**ï¼ˆæˆ–ä½ è‡ªå·±ï¼‰æˆåŠŸç»˜åˆ¶ä¸€ä¸ªç‚¹æ—¶è§¦å‘ã€‚ç”¨äºå®æ—¶åŒæ­¥ç”»å¸ƒã€‚

- **æ•°æ®**: åŒ…å«å®Œæ•´çš„ç‚¹ä¿¡æ¯ (`x`, `y`, `c`, `user`, `create_at` ç­‰)ã€‚

    ```json
    {
        "x": 0,
        "y": 0,
        "h": 1,
        "w": 1,
        "c": "#000000"
    }
    ```

##### `onlineClientsUpdated`

å½“åœ¨çº¿ç”¨æˆ·æ•°é‡å˜åŒ–æ—¶è§¦å‘ã€‚

- **æ•°æ®**:

    ```json
    {
        "count": 123
    }
    ```

#### æˆ¿é—´å†…æ¨é€äº‹ä»¶

åªæœ‰æ ¹æ® token åŠ å…¥æˆ¿é—´åæ‰ä¼šæŒ‰ token å¹¿æ’­çš„ç§æœ‰äº‹ä»¶ã€‚

##### `sync`

å½“ä½ å‘é€ `draw` è¯·æ±‚åï¼Œæ— è®ºæˆåŠŸä¸å¦ï¼ŒæœåŠ¡ç«¯å¯èƒ½ä¼šå‘é€æ­¤äº‹ä»¶æ¥å¼ºåˆ¶åŒæ­¥å®¢æˆ·ç«¯çš„å‰©ä½™ç‚¹æ•°ã€‚

- **æ•°æ®**:

    ````json
    {
        "pointsLeft": 10,
        "lastUpdate": 1766427449915
    }
    ````

## æ ·ä¾‹

### ç´§æ€¥æ›´æ–°ï¼šå…³äºåœ¨æ ¡å†…éƒ¨åˆ†ç½‘æ®µæ— æ³•è¿æ¥æœåŠ¡å™¨çš„è§£å†³åŠæ³•

æˆ‘ä»¬å‘ç°åœ¨éƒ¨åˆ†ç½‘æ®µä¸‹ï¼ˆä¾‹å¦‚å¯å®¤å’Œéƒ¨åˆ†åœ°ç‚¹ï¼‰æ— æ³•é€šè¿‡ Python çš„ Websocket ä¸æœåŠ¡å™¨æ­£å¸¸è¿æ¥ã€‚ç»è¿‡æ’æŸ¥ï¼Œæˆ‘ä»¬åˆæ­¥æ–­å®šè¿™æ˜¯ç”±äºå›¾ä¿¡çš„ DNS å°†æœåŠ¡å™¨è§£ææˆ IPv6 ä½†æ˜¯æ²¡æœ‰æ­£ç¡®é…ç½® IPv6 å‡ºå£ç­‰åŸºç¡€è®¾æ–½çš„åŸå› ã€‚ğŸ˜ 

å¦‚æœä½ ä½¿ç”¨çš„æ˜¯è‡ªå·±çš„è„šæœ¬ï¼ŒåŠ å…¥ä¸‹åˆ— patch åœ¨æœ€å‰æ–¹å³å¯å¼ºåˆ¶ä½¿ç”¨ IPv4 è§£æï¼š

```python
import socket

old_getaddrinfo = socket.getaddrinfo

def getaddrinfo_ipv4_only(host, port, *args, **kwargs):
    # åªä¿ç•™è¿”å› AF_INETï¼ˆIPv4ï¼‰çš„è§£æç»“æœ
    results = old_getaddrinfo(host, port, *args, **kwargs)
    return [res for res in results if res[0] == socket.AF_INET]

socket.getaddrinfo = getaddrinfo_ipv4_only
```

### ç¯å¢ƒå‡†å¤‡

ä¸‹é¢ç»™å‡ºè¾ƒç°ä»£çš„ uv æ ¼å¼çš„ç¯å¢ƒï¼Œä¿å­˜ä¸º `pyproject.toml` åç”¨ `uv sync` å³å¯ã€‚

```toml
[project]
name = "paint-bot"
version = "0.1.0"
description = "paint2025 bot"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "pillow>=12.0.0",
    "python-socketio>=5.15.1",
    "requests>=2.32.5",
    "websocket-client>=1.9.0",
]
```

æˆ–è€…ä½¿ç”¨ `requirements.txt` ä»¥åŠ `pip` æ‰‹åŠ¨å®‰è£…ä¸Šè¿° 4 ä¸ªä¾èµ–ä¹Ÿå¯ä»¥è§£å†³é—®é¢˜ã€‚æ³¨æ„ä¸è¦å®‰è£… `socketio` åº“ã€‚

### ä»£ç 

å…³äºå¡«æ¶‚ç­–ç•¥ï¼Œä½ å¯ä»¥é€‰æ‹©é¡ºåºå¡«æ¶‚æˆ–è€…é˜²å¾¡æ€§æ›´å¥½çš„å’Œæ›´é€‚åˆå¹¶è¡Œçš„æ•£ç‚¹å¼ç»˜å›¾ã€‚

ä¸‹é¢æ˜¯ä¸€ä¸ªæ¥è‡ª [@Gregtaoo](https://github.com/GregTaoo/) ç¼–å†™çš„åŸºæœ¬æ ·ä¾‹ç¨‹åºï¼ŒåŸºæœ¬å®ç°äº†å¤š Token å’Œç»˜å›¾ï¼Œä½†ç¼ºå°‘å¯¹ Delay Time çš„è®¡ç®—å’Œå®æ—¶ç›‘å¬ `sync` åŒæ­¥çš„è¿‡ç¨‹ã€‚

```python
import argparse
import time
import requests
from PIL import Image
import socketio
import threading

def rgb_to_hex(r, g, b):
    return f"#{r:02x}{g:02x}{b:02x}"

def get_canvas_points():
    resp = requests.get("https://paint2025.geekpie.club/api/place")
    resp.raise_for_status()
    data = resp.json()
    points = {}
    for p in data.get("data", {}).get("points", []):
        points[(int(p["x"]), int(p["y"]))] = p["c"].lower()
    return points

# =========================
# å• token Socket.IO å®¢æˆ·ç«¯
# =========================
class TokenClient:
    def __init__(self, token: str):
        self.token = token
        self.sio = socketio.Client(
            logger=False,
            engineio_logger=False
        )
        self.connected = False

        @self.sio.event
        def connect():
            self.connected = True
            print(f"[socketio] token {self.token[:6]} connected")

        @self.sio.event
        def disconnect():
            self.connected = False
            print(f"[socketio] token {self.token[:6]} disconnected")

    def connect(self):
        self.sio.connect(
            "https://paint2025.geekpie.club",
            transports=["websocket"],
            wait=True,
            wait_timeout=30,
            auth={
                "token": self.token
            }
        )

    def draw(self, x, y, color):
        if not self.connected:
            return False
        self.sio.emit(
            "draw",
            {
                "data": {"w": 1, "h": 1, "x": x, "y": y, "c": color},
            },
        )
        return True

    def close(self):
        if self.connected:
            self.sio.disconnect()

# =========================
# ä¸»ç»˜åˆ¶é€»è¾‘
# =========================
def draw_image_until_complete(img_path, width, height, start_x, start_y, tokens_str):
    tokens = [t.strip() for t in tokens_str.split(",") if t.strip()]
    if not tokens:
        raise ValueError("No valid tokens")

    print(f"Starting with {len(tokens)} tokens")

    # åˆ›å»º token å®¢æˆ·ç«¯
    clients = [TokenClient(t) for t in tokens]

    # å¹¶è¡Œè¿æ¥
    threads = []
    for c in clients:
        t = threading.Thread(target=c.connect, daemon=True)
        t.start()
        threads.append(t)

    for t in threads:
        t.join()

    img = Image.open(img_path).convert("RGB")
    img = img.resize((width, height), Image.LANCZOS)
    pixels = img.load()

    client_index = 0
    sleep_time = 0.25

    try:
        while True:
            canvas = get_canvas_points()
            all_done = True

            for dy in range(height):
                for dx in range(width):
                    x = start_x + dx
                    y = start_y + dy
                    r, g, b = pixels[dx, dy]
                    color = rgb_to_hex(r, g, b).lower()

                    if canvas.get((x, y)) != color:
                        all_done = False

                        client = clients[client_index]
                        client_index = (client_index + 1) % len(clients)

                        if client.draw(x, y, color):
                            print(
                                f"[draw] x={x}, y={y}, color={color}, token={client.token[:6]}"
                            )
                        else:
                            print(
                                f"[draw] skipped (not connected) token={client.token[:6]}"
                            )

                        time.sleep(sleep_time)

            if all_done:
                print("All pixels match the target image!")
                break
            else:
                print("Not finished, checking again")
                time.sleep(5)
    finally:
        for c in clients:
            c.close()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--image", required=True)
    parser.add_argument("--width", type=int, required=True)
    parser.add_argument("--height", type=int, required=True)
    parser.add_argument("--start-x", type=int, required=True)
    parser.add_argument("--start-y", type=int, required=True)
    parser.add_argument("--tokens", required=True)
    args = parser.parse_args()

    draw_image_until_complete(
        args.image,
        args.width,
        args.height,
        args.start_x,
        args.start_y,
        args.tokens,
    )

if __name__ == "__main__":
    main()
```

